"""
Creat time:2020-1-18下午
TimeToCode：
Last modified time: 

4.两个有序数组的中位数

给定两个长度分别为m和n的有序数组，找到两个数组的中位数。
注意：时间复杂度要求为O(log(m+n))

Example 1:
nums1 = [1, 3]
nums2 = [2]
The median is 2.0

Example 2:
nums1 = [1, 2]
nums2 = [3, 4]
The median is (2 + 3)/2 = 2.5

"""

class Solution:
    # 我没有思路，《leetcode》的解法如下：
    
    # 例如a=[1 2 3 4 6 9]和b=[1 1 5 6 9 10 11], 数字个数为13.
    # 目标是找到第7大的数字. int(7/2)=3, a[3]<b[3], 
    # 所以a[0]a[1]a[2]不在考虑范围之内了, 因为它们不可能是第七大的数字. 
    # 然后在不包含a[0]a[1]a[2]的其它数字中找到第七大的数字
    # 如上所述，每次缩小至一半的数字... ....


    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:

        m, n = len(nums1), len(nums2)
        
        # 下面三行代码非常巧妙，将长度为偶数和奇数的数组统一为同一种计算方式
        l = (m + n + 1) // 2
        r = (m + n + 2) // 2
        return (self.getkth(nums1, m ,nums2, n, l) + self.getkth(nums1, m, nums2, n, r)) / 2.0

    def getkth(self, A, m, B, n, k):

        # let m <= n
        if m > n:
            return self.getkth(B, n, A, m, k)

        # 两个边界条件：
        # 存在数组为空时，返回不为空的数组的第k个数字；
        # 中位数是第一个数字时，返回两个数组首元素中较小的值
        if m == 0:
            return B[k - 1]
        if k == 1:
            return min(A[0], B[0])

        step1, step2 = min(m, k//2), min(n, k//2)
        if A[step1-1] > B[step2-1]:
            return self.getkth(A, m, B[step2:], n - step2, k - step2)
        else:
            return self.getkth(A[step1:], m - step1, B, n, k - step1)

        return 0