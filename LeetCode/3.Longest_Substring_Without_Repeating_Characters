"""
Creat time:2020-2-3下午
TimeToCode：
Last modified time: 

3.无重复字符的最长子串

给定一个字符串，找出最长的没有重复字符的子字符串

Example 1:
    Input: "abcabcbb"
    Output: 3 
    Explanation: The answer is "abc", with the length of 3. 

Example 2:
    Input: "bbbbb"
    Output: 1
    Explanation: The answer is "b", with the length of 1.

Example 3:
    Input: "pwwkew"
    Output: 3
    Explanation: The answer is "wke", with the length of 3. 
    Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

"""

class Solution_1:

    # 最长子串，最先想到的解法是“动态规划”

    # 思路如下：
    # 用一维数组d[]，记录以数组第i位元素结尾的最长的子字符串的长度。
    # 如果第i个元素在数组中不是第一次出现，并且距离前一次出现时的距离<d[i-1]，那么d[i]=这段距离
    # 否则，d[i] = d[i-1] + 1

    # 具体做法：
    # 用以字母元素为key以list为value的哈希表，记录每个字母在字符串出现过的下标
    # 用一维数组d[]，记录以数组第i位元素结尾的最长的子字符串的长度。
    # 遍历字符串中的每个字母元素：
    # 记distance为该字母距离上次出现时的距离(如果第一次出现则为0)
    # 如果distance <= d[i-1]，说明该字母已经在这个子字符串中出现过
    # 此时，我们要用新的子字符串，新子字符串的长度就等于distance
    # 反之，如果distance > d[i-1]，说明该字母在这个子字符串中没有出现过，
    # 此时，当前元素可以添加到已有的子字符串中，字符串的长度变为d[i-1]+1


    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s: return 0
        
        hasht = collections.defaultdict(list)
        for i in range(len(s)):
            hasht[s[i]].append(i)
            
        d = [1] * len(s)
        
        for i in range(1, len(s)):
            cur = hasht[s[i]].index(i)
            distance = hasht[s[i]][cur] - hasht[s[i]][cur-1]
            
            if cur > 0 and  distance <= d[i-1]:
                d[i] = distance
            else:
                d[i] = d[i-1] + 1
                    
        return max(d)


class Solution_2:

    # 这道题，显然是“滑动窗口”问题
    # 可以用“双指针”，下面是《csdn》中的解答

    # 思路如下：
    # 一个指针pre指向无重复子字符串的开头，一个指针cur移动指向当前字符（子字符串的结尾是cur-1）
    # 子字符串长度即为两者的差
    # 判断子字符串中 是否含有cur当前指向的元素
    # 若不含，则cur+1；
    # 若包含，找出子字符串中重复该元素的位置，将pre指向下一个元素，
    # 并且，cur继续回到判断这一步，直到将整个字符串都遍历


    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s: return 0

        hasht = collections.defaultdict(list)
        for i in range(len(s)):
            hasht[s[i]].append(i)
        
        start, end, max_len = 0, 1, 1
        
        while end < len(s):
            cur = hasht[s[end]].index(end)
            pre = hasht[s[end]][cur-1] if cur > 0 else -1
            
            if pre < start:
                end += 1
            else:
                start = pre + 1
            
            max_len = max(max_len, end-start)
                    
        return max_len