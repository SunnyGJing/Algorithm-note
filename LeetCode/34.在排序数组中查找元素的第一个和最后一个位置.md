> Create time: 2021-9-22
## 34.【Medium】在排序数组中查找元素的第一个和最后一个位置
#### 题目描述
给定1个升序数组`nums`和1个目标值`target`，返回目标值在数组中的开始和结束的位置。如不存在，则返回`[-1, -1]`。  

**进阶**：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
   
- 示例 1：
    ```
    输入：nums = [5,7,7,8,8,10], target = 8
    输出：[3,4]
    ```
- 示例 2：
    ```
    输入：nums = [5,7,7,8,8,10], target = 6
    输出：[-1,-1]
    ```
- 示例 3：
    ```
    输入：nums = [], target = 0
    输出：[-1,-1]
    ```

**提示**:  
- 0 <= nums.length <= 105
- -109 <= nums[i] <= 109
- nums 是一个非递减数组
- -109 <= target <= 109

### 解法
- 解法1：  
**此解法不可取**，最坏时间复杂度是O(n)  
首先采用二分法寻找target所在的下标，然后向两边遍历拓展，寻找起点和终点。

- 解法2：  
《算法笔记》中的解法  
**二分查找**定范围，即 `[第一个大于等于target，第一个大于target)`  
注意是左闭右开  
细节请看代码注释

#### 代码
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        low, high = 0, len(nums)-1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] > target:
                high = mid - 1
            elif nums[mid] < target:
                low = mid + 1
            else:
                while nums[high] > target:
                    high -= 1
                while nums[low] < target:
                    low += 1
                return [low, high]
        return [-1, -1] 
```

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        if n == 0: return [-1, -1]

        # step 1 寻找左边界：第一个大于等于target的下标
        low, high = 0, n-1
        while low < high:
            mid = (low + high) // 2
            if nums[mid] >= target:
                high = mid
            elif nums[mid] < target:
                low = mid + 1
        # 特殊情况：目标元素比数组任意元素大
        start = low if nums[low] >= target else n

        # step 2 寻找有边界：第一个大于target的下标
        low, high = 0, len(nums)-1
        while low < high:
            mid = (low + high) // 2
            if nums[mid] > target:
                high = mid
            elif nums[mid] <= target:
                low = mid + 1
        # 特殊情况：目标元素比数组任意元素大
        end = low if nums[low] > target else n

        return [start, end-1] if start != end else [-1, -1]
```