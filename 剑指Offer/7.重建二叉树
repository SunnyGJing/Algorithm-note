"""
Creat time: 2019-07-24 09:48
Last modified time: 

根据前序和中序遍历结果，重建二叉树。

"""
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };

class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty()) return NULL;
        TreeNode* root = new TreeNode(pre[0]);
        int k = findK(pre, vin);
        root->left = reConstructBinaryTree(vector<int>(pre.begin()+1,pre.begin()+k+1), vector<int>(vin.begin(),vin.begin()+k));
        root->right = reConstructBinaryTree(vector<int>(pre.begin()+k+1,pre.end()), vector<int>(vin.begin()+k+1,vin.end()));
        
        return root;
    }
    int findK(vector<int> pre, vector<int> vin) {
        int root = pre[0];
        int k;
        for(int i=0; i<vin.size(); i++) {
            if(vin[i] == root){
                k = i;
                break;
            }
    }
    return k;
}
};

