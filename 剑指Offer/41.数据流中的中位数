"""
Creat time:
TimeToCode：
Last modified time: 

解法：《剑指offer》的解法，非常赞。具体是用一个大顶堆和一个小顶堆共同实现，
要保证两件事，一是两个堆的元素数相差不超过1，二是大顶堆中的元素小于小顶堆中的元素。

PS: Solution_1是自己写的代码，Solution_2是书中的代码。
"""

class Solution_1 {
public:
    vector<int> maxHeap;
    vector<int> minHeap;
    int count = 0;

    void Insert(int num) {
        ++count;
        if((count << 1))
            insertMaxHeap(num);
        else
            insertMinHeap(num);
    }

    double GetMedian() { 
        if(count==0) return 0;
        if((count << 1))
            return minHeap.size()<maxHeap.size() ? maxHeap[0] : minHeap[0];
        else
            return (maxHeap[0] + minHeap[0]) / 2; 

    }

    void insertMaxHeap(int num) {
        if(num > maxHeap[0])
            moveToMinHeap(num);
        else {
            maxHeap.push_back(num);
            adjustMaxHeap(0);
        }
    }

    void insertMinHeap(int num) {
        if(num < minHeap[0])
            moveToMaxHeap(num);
        else {
            minHeap.push_back(num);
            adjustMinHeap(0);
        }
    }

    void adjustMaxHeap(int pos) {
        int length = maxHeap.size();
        while(true) {
            int child = pos * 2 + 1;
            if(child >= length.size()) break;
            if(child+1<length && maxHeap[child]<maxHeap[child+1])
                ++child;
            if(maxHeap[pos] < maxHeap[child]) {
                swap(maxHeap[child], maxHeap[pos]);
                adjustMaxHeap(child);
            }
            else break;
        }
    }

    void adjustMinHeap(int pos) {
        int length = minHeap.size();
        while(true) {
            int child = pos * 2 + 1;
            if(child >= length.size()) break;
            if(child+1<length && maxHeap[child]>maxHeap[child+1])
                ++child;
            if(minHeap[pos] > minHeap[child]) {
                swap(minHeap[child], minHeap[pos]);
                adjustMinHeap(child);
            }
            else break;
        }
    }

    void moveToMinHeap(int num) {
        maxHeap.push_back(minHeap[0])
        minHeap.erase(minHeap.begin());
        minHeap.push_back(num);
        adjustMinHeap();
        adjustMaxHeap();
    } 

    void moveToMaxHeap(int num) {
        minHeap.push_back(maxHeap[0]);
        maxHeap.erase(maxHeap.begin());
        minHeap.push_back(num);
        adjustMaxHeap();
        adjustMinHeap();
    } 
};


class Solution_2 {
public:
    void Insert(int num) {
        if(((minHeap.size() + maxHeap.size()) & 1) == 0) {
            if(maxHeap.size() > 0 && num < maxHeap[0]) {
                maxHeap.push_back(num);
                push_heap(maxHeap.begin(), maxHeap.end(), less<int>());
                num = maxHeap[0];
                pop_heap(maxHeap.begin(), maxHeap.end(), less<int>());
                maxHeap.pop_back();
            }
            minHeap.push_back(num);
            push_heap(minHeap.begin(), minHeap.end(), greater<int>());
        }
        else {
            if(minHeap.size() > 0 && num > minHeap[0]) {
                minHeap.push_back(num);
                push_heap(minHeap.begin(), minHeap.end(), greater<int>());
                num = minHeap[0];
                pop_heap(minHeap.begin(), minHeap.end(), greater<int>());
                minHeap.pop_back();
            }
            maxHeap.push_back(num);
            push_heap(maxHeap.begin(), maxHeap.end(), less<int>());
        }
    }

    double GetMedian() { 
        int size = minHeap.size() + maxHeap.size();
        if(size == 0)
            throw exception("No numbers are available");
        int median = 0;
        if((size & 1) == 1)
            median = minHeap[0];
        else
            median = (minHeap[0] + maxHeap[0]) / 2;
        return median
    }
    
private:
    vector<int> minHeap;
    vector<int> maxHeap;
}