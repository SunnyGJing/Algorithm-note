> Create time: 2019-12-30晚上  
> Update time: 2021-10-18上午

### [剑指Offer 64.【Medium】求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

#### 题目描述
求1+2+……+n，要求**不能使用**乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A?B:C)

- Example:
    ```
    Input: n = 3
    Output: 6
    ```  
- Example:
    ```
    Input: n = 9
    Output: 45
    ```  

- 限制：  
    `1 <= n <= 10000`

#### 解法
除了 `if` 和 `switch` 等判断语句外，是否有其他方法可用来终止递归？

答案就是：**逻辑运算符短路**

- `if(A && B)`，如果 A 为 false，则 B 的判断不会执行（即 && 短路），直接判定 A && B 为 false`

- `if(A || B)`，如果 A 为 true，则 B 的判断不会执行（即 || 短路），直接判定 A || B 为 true

本题需要实现 “当 n = 1 时终止递归” 的需求，可通过短路效应实现。

- `n > 1 && sumNums(n - 1)`
  - 当n > 1 时，执行sumNums(n-1)；
  - 当n = 1 时，此时 “短路” ，终止后续递归

#### 代码
##### python版
```python
class Solution:
    def __init__(self):
        self.res = 0
    def sumNums(self, n: int) -> int:
        n > 1 and self.sumNums(n - 1)
        self.res += n
        return self.res
```

##### cpp版
```cpp
class Solution_1 {

    // 好难哦
    // 《leetcode》的解法特别巧妙！
    // 思路：
    // 利用编程语言中的逻辑与的短路求值特性，达到了if的同等效果
    
    // PS: 缺点：递归层数不能太深<3000
public:
    int Sum_Solution(int n) {
        int ans = n;
        ans && (ans += Sum_Solution(n - 1));

        return ans;
    }
};   
```   

```cpp
// 《剑指offer》的解法1如下： 利用构造函数求解
// 思路：
// 利用构造函数被调用n次，达到了循环的同等效果
// 我们可以把累加相关的代码放到构造函数里

class Temp {
public:
    Temp() {++N; Sum+=N;}
    static void Reset() {N=0; Sum=0;}
    static int GetSum() {return Sum;}

private:
    static int N;
    static int Sum;
};

int Temp::N = 0;
int Temp::Sum = 0;

class Solution_2 {
public:
    int Sum_Solution(int n) {
        Temp::Reset();
        Temp *a = new Temp[n];
        delete []a;
        a = nullptr;

        return Temp::GetSum();
    }
};
```
```cpp
// 《剑指offer》的解法2如下： 利用虚函数求解
// 思路：
// 既然不能在一个函数中判断是不是该种植递归，那不妨定义两个函数
// 一个函数充当递归函数的解，另一个函数处理终止递归的情况
// 如何选择用到哪一个函数呢？可以用布尔变量来控制
// 而数值变量n如何转换成布尔值呢？可以用对n做两次反运算，!!n

class A;
A* Array[2];

class A{
public:
     virtual int Sum(int n) {
        return 0;
    }
};

class B: public A {
public:
    virtual int Sum(int n) {
        return Array[!!n]->Sum(n-1) + n;
    }
};

class Solution_3 {
public:
    int Sum_Solution(int n) {
        A a;
        B b;
        Array[0] = &a;
        Array[1] = &b;

        int value = Array[1]->Sum(a);
        return value;
    }
};
```
```cpp
class Solution_3 {
    // 《剑指offer》的解法3如下： 利用函数指针求解
    // 解法3实际上等同于解法2，只是使用指针所以更加直观
public:
    typedef int (*fun)(int);

    int Solution_Teminator(int n) {
        return 0;
    }

    int Sum_Solution(int n) {
        static fun f[2] = {Solution_Teminator, Sum_Solution};
        return n + f[!!n](n-1);
    }
```
```cpp
class Solution_4 {
    // 《剑指offer》的解法4如下： 利用模板类型求解
    // 编译器看到模板类未显式定义的参数类型，会以该参数生成该类型的代码
    // 直到某参数的类型已经显式定义，编译器无需生成，递归编译到此结束
    
    // PS:缺点 1.输入n需是在编译期间就能确定的常量，不能动态输入
    // 2.出于递归限制，n不能太大
public:

template <int n> struct Sum_Solution { 
    enum value {N = Sum_Solution<n-1>::N + n}; 
};
template <> struct Sum_Solution<1> { 
    enum value {N = 1};
}
```