> Creat time: 2019-12-23早上  
> Update time: 2022-2-11

### [剑指 Offer 51.【Hard】数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)
#### 题目描述
给定一个数组，求出数组中的逆序对个数。最终结果要对1000000007取模。

- Example:
    ```
    Input: [7,5,6,4]
    Output: 5
    ```  
- 限制：  
    `0 <= 数组长度 <= 50000`
#### 解法
直观思路是遍历数组中的每个元素，并求出排在后面的比它小的元素个数，把计算得的个数累计相加

但复杂度是O(N^2),应该找出更有效的算法，优化时间效率

《剑指offer》中的算法巧妙，思路如下：
- 求出子数组内部的逆序对个数，再求出子数组之间的逆序对个数，并在此过程中完成数组元素的排序。
- 类似于**归并排序**，详见教程 [剑指 Offer 51. 数组中的逆序对（归并排序，清晰图解）](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/)

#### 代码
##### python版
```python
class Solution:
    def __init__(self):
        self.res = 0

    def reversePairs(self, nums: List[int]) -> int:
        self.helper(nums, len(nums))
        return self.res

    def helper(self, nums, n):
        if n == 0 or n == 1 or (n == 2 and nums[0] <= nums[1]):
            return nums
        if n == 2 and nums[0] > nums[1]:
            self.res += 1 
            return [nums[1], nums[0]]
        nums_low = self.helper(nums[:n//2], n//2)
        nums_high = self.helper(nums[n//2:], n-n//2)

        nums, low, high = [], 0, 0
        while low < n//2 and high < n - n//2:
            if nums_low[low] <= nums_high[high]:
                nums.append(nums_low[low])
                low += 1
            else:
                nums.append(nums_high[high])
                high += 1
                self.res += n//2 - low  # low当前元素到末尾元素的个数
        if low < n//2: nums += nums_low[low:]
        if high < n - n//2: nums += nums_high[high:]

        return nums
```

##### cpp版
```cpp
class Solution {
public:
    int InversePairs(vector<int> data) {
        if(data.empty()) return 0;
        // 需要一个辅助数组，因为直接对原数组排序会影响结果
        vector<int> copy(data.begin(), data.end());

        int count = InversePairCouting(data, copy, 0, data.size()-1);
        return count;
    }

    int InversePairCouting(vector<int>& data, vector<int>& copy, int low, int high) {
        if(high == low)
            return 0;
        
        int mid = (low + high) / 2;
        int leftCount = InversePairCouting(data, copy, low, mid);
        int rightCount = InversePairCouting(data, copy, mid+1, high);
        int count = 0;
        int low1 = low, high1 = mid, low2 = mid+1, high2 = high;
        int index1 = high1, index2 = high2, indexCopy = high2;

        while(index1 >= low1 && index2 >= low2) {
            if(data[index1] > data[index2]){
                copy[indexCopy--] = data[index1--];
                count += (index2 - high1);
                count %= 1000000007;
            }
            else
                copy[indexCopy--] = data[index2--];
        }
        while(index1 >= low1) 
            copy[indexCopy--] = data[index1--];
        while(index2 >= low2)
            copy[indexCopy--] = data[index2--];
        
        for(int i=low1; i<=high2; ++i)
            data[i] = copy[i];
        return (c1 + rightCount + count) % 1000000007;
    }
};
```