"""
Creat time: 2019-07-26 17:59
Last modified time: 2019-07-27 19:53


给定一个矩阵，判断在矩阵中是否存在字符串路径。（回溯法）

思路：
dfs
解法1是自己的解法
解法2是《剑指offer》的解法
"""

class Solution_1 {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        if(strlen(matrix)==0 || rows<=0 || cols<=0) return false;
        bool *flag = new bool[rows*cols]; //学习数组型指针的初始化
        memset(flag, false, rows*cols);
        for(int row=0; row<rows; row++) {
            for(int col=0; col<cols; col++) {                    
                if(findString(matrix,rows,cols,row,col,str,flag))
                    return true;
            }
        }
        return false;    
    }
    bool findString(char* &matrix, int rows, int cols, int row_index, int col_index, char* str, bool* &flag) {
        if(matrix[row_index*cols+col_index]!=str[0]) return false;
        int direct_row[]={-1,0,1,0};
        int direct_col[]={0,-1,0,1};
        int start_i = row_index, start_j = col_index, strindex=0;
        stack<int> row;
        stack<int> col;
        row.push(start_i);
        col.push(start_j);
        strindex += 1;
        flag[start_i*cols+start_j] = true;
        while(strindex<strlen(str)) {
            for(int n=0; n<4; n++) {
                int cur_i = start_i+direct_row[n];
                int cur_j = start_j+direct_col[n];
                if(cur_i>=0 && cur_i<rows && cur_j>=0 && cur_j<cols) {
                    if(str[strindex]==matrix[cur_i*cols+cur_j] && flag[cur_i*cols+cur_j]==false) {
                        row.push(cur_i);
                        col.push(cur_j);
                    }
                }
            }
            if(flag[row.top()*cols+col.top()] == false) {
                start_i = row.top();
                start_j = col.top();
                flag[start_i*cols+start_j] = true;
                strindex += 1;
            }
            else {
                flag[row.top()*cols+col.top()] = false;
                row.pop();
                col.pop(); // 要注意，pop后要做越界检查
                if(row.empty() || col.empty() || flag[row.top()*cols+col.top()]==true)
                    return false;
                else {
                    start_i = row.top();
                    start_j = col.top();
                    flag[start_i*cols+start_j] = true;
                }
            }
        }
        return true;
    }
};


class Solution_2 {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        if(matrix==nullptr || rows<1 || cols<1 || str==nullptr)
            return false;
        bool* visited = new bool[rows*cols];
        memset(visited, 0, rows*cols);

        int pathLength = 0;
        for(int row=0; row<rows; ++row) {
            for(int col=0; col<cols; ++col) {
                if(hashPathCore(matrix,rows,cols,row,col,str,pathLength,visited)) 
                    return true;
            }
        }
        delete[] visited;
        return false;
    }
    
    bool hasPathCore(const char* matrix, int rows, int cols, int row,
        int col, const char* str, int& pathLength, bool* visited) 
    {
        if(str[pathLength] == '\0')
            return true;
        bool hasPath = false;
        if(row>=0 && row<rows && col>=0 && col<cols
            && matrix[rows*cols+col]==str[pathLength]
            && !visited[row*cols+col])
        {
            ++pathLength;
            visited[row*cols+col] = true;
            hasPath = hasPath(matrix,rows,cols,row,col-1,str,pathLength,visited)
                ||  hasPath(matrix,rows,cols,row,col+1,str,pathLength,visited)
                ||  hasPath(matrix,rows,cols,row-1,col,str,pathLength,visited)
                ||  hasPath(matrix,rows,cols,row+1,col,str,pathLength,visited);
            if(!hasPath) {
                --pathLength;
                visited[row*cols+col]=false;
            }
        }
        return hasPath;
    }
};