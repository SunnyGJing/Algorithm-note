"""
Creat time: 2019-07-26 17:59
Last modified time: 2019-07-27 19:53


给定一个矩阵，判断在矩阵中是否存在字符串路径。（回溯法）

思路：
dfs
"""

class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        if(strlen(matrix)==0 || rows<=0 || cols<=0) return false;
        bool *flag = new bool[rows*cols]; //学习数组型指针的初始化
        memset(flag, false, rows*cols);
        for(int row=0; row<rows; row++) {
            for(int col=0; col<cols; col++) {                    
                if(findString(matrix,rows,cols,row,col,str,flag))
                    return true;
            }
        }
        return false;    
    }
    bool findString(char* &matrix, int rows, int cols, int row_index, int col_index, char* str, bool* &flag) {
        if(matrix[row_index*cols+col_index]!=str[0]) return false;
        int direct_row[]={-1,0,1,0};
        int direct_col[]={0,-1,0,1};
        int start_i = row_index, start_j = col_index, strindex=0;
        stack<int> row;
        stack<int> col;
        row.push(start_i);
        col.push(start_j);
        strindex += 1;
        flag[start_i*cols+start_j] = true;
        while(strindex<strlen(str)) {
            for(int n=0; n<4; n++) {
                int cur_i = start_i+direct_row[n];
                int cur_j = start_j+direct_col[n];
                if(cur_i>=0 && cur_i<rows && cur_j>=0 && cur_j<cols) {
                    if(str[strindex]==matrix[cur_i*cols+cur_j] && flag[cur_i*cols+cur_j]==false) {
                        row.push(cur_i);
                        col.push(cur_j);
                    }
                }
            }
            if(flag[row.top()*cols+col.top()] == false) {
                start_i = row.top();
                start_j = col.top();
                flag[start_i*cols+start_j] = true;
                strindex += 1;
            }
            else {
                flag[row.top()*cols+col.top()] = false;
                row.pop();
                col.pop(); // 要注意，pop后要做越界检查
                if(row.empty() || col.empty() || flag[row.top()*cols+col.top()]==true)
                    return false;
                else {
                    start_i = row.top();
                    start_j = col.top();
                    flag[start_i*cols+start_j] = true;
                }
            }
        }
        return true;
    }
};