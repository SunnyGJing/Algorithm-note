"""
Creat time: ----
Last modified time: 2019-06-25 03：17
在一个长度为n的数组里的所有数字都在0到n-1的范围内。判断数组中是否有重复出现
的数字，返回bool值，找到任意重复的一个值就赋值到duplication[0]。
     
3种Solution
复杂度依次为 O(nlogn)+O(1) / O(n)+O(n) / O(n)+O(1)
预览一下~ 主要code依次为 sort->if(a[i]==a[i+1]) / hash->if(hash[a[i]]=1) / find element not equal to its index
(数组元素是0~数组长度n之间的整数，可利用下标)
"""

class Solution_1:
    # 这里要特别注意~找到任意重复的一个值并赋值到指针duplication
    # 函数返回true/false
    bool duplicate(int numbers[], int length, int* duplication) {
        if(length==0) return false;
        sort(numbers, numbers+length);
        for(int i=0; i<length-1; i++) {
            if(numbers[i]==numbers[i+1]) {
                *(duplication) = numbers[i];
                return true;
            }
        }
        return false;
    }

class Solution_2:
    # 这里要特别注意~找到任意重复的一个值并赋值到指针duplication
    # 函数返回true/false
    bool duplicate(int numbers[], int length, int* duplication) {
        unordered_map<int,bool> hasht;
        if(length==0) return false;
        for(int i=0; i<length; i++) {
            if(hasht[numbers[i]]==true) {
                *(duplication) = numbers[i];
                return true;
            }
            else
                hasht[numbers[i]] = true;
        }
        return false;
    }

class Solution_3:
    # 这里要特别注意~找到任意重复的一个值并赋值到指针duplication
    # 函数返回True/False
    bool duplicate(int numbers[], int length, int* duplication) {
        if(length == 0) return false;
        for(int i=0; i<length; i++) {
            while(numbers[i] != i) {
                if(numbers[numbers[i]] == numbers[i]){
                    *(duplication) = numbers[i];
                    return true;
                }
                int tmp = numbers[numbers[i]];
                numbers[numbers[i]] = numbers[i];
                numbers[i] = tmp;
            }
        }
        return false;
    }