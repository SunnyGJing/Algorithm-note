
```
题目：  
leetcode 3
```

### 题解
#### 1. 动态规划状态转移式
```
    dp[i] = dp[i-1] + 1                 if nums[i]没有在子串中出现过
    dp[i] = nums[i]与上次出现的距离     if nums[i]在子串中出现过
```
Note：
1. 如何判断nums[i]有没有在以nums[i-1]为结尾的子串中出现过：
    - 先计算nums[i]本次出现与上次出现的距离distance；
    - 如果distance大于子串长度，说明nums[i]在子串中没有出现过；
    - 如果distance小于子串长度，说明nums[i]在子串中已经存在了；
2. 如果计算nums[i]与上次出现的距离distance：
    - 提前用哈希表defaultdict(list)记录每个字符的所有下标；
    - 那么，就可以通过hasht[nums[i]].index(i)获取当前是该字符第几次出现(从0开始)(这里记为变量inx)；
    - 距离就等于hasht[nums[i]][inx] - hasht[nums[i]][inx-1]；

#### 2. 动态规划优化：
- 原做法
    - 用一维数组dp记录以nums[i]为结尾的最长子串长度，最后求max
- 优化后做法
    - 只记录以nums[i-1]为结尾的最长字串长度，及时更新max
        
### Code
##### 解法
```python
import collections

def longestSubstringWithoutDuplication(s):

    hasht = collections.defaultdict(list)   # 用哈希表记录每个字符的所有下标
    for i, c in enumerate(s):
        hasht[c].append(i)

    cur_length, max_length = 0, 0
    for i, c in enumerate(s):
        inx = hasht[c].index(i)
        if inx == 0 or hasht[c][inx] - hasht[c][inx-1] > cur_length:    # 如果当前字符在子串中没有出现过，直接拼接到子串中
            cur_length += 1
        else:   # 否则，新的子串就是当前字符到上次出现之间的子串
            cur_length = hasht[c][inx] - hasht[c][inx-1]
        max_length = max(max_length, cur_length)    # 更新最大子串长度

    return max_length
```