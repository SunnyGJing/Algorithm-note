
```
题目：  
leetcode 718
```

### 题解
#### 1. 动态规划状态转移式：（非常慢）
```
    dp[i][0] = 0                                    for all i
    dp[0][j] = 0                                    for all j
    dp[i][j] = dp[i-1][j-1] + 1                     if text1[i] == text2[j]
    dp[i][j] = 0                                    if text1[i] != text2[j]
```
Note：  
1. 对dp状态转移方程的解释
    - 子串要求连续，所以如果当前两个元素不相等，dp值需要初始化为1。
2. dp数组初始化
    - 为了省去初始化base case的步骤，我们让dp的大小为(n + 1) * (m + 1)。

#### 2. 动态规划优化：
- 原做法
    - 用二维数组dp记录以text1[i]和text2[j]为结尾的两个字符串的最长公共子串长度，最后返回max（注意！这里返回max，而不是像公共子序列那样返回dp[-1][-1]）
- 优化后做法
    - 暂时没研究

### Code
##### 解法
```python
def longestCommonSubarray(A, B):
    m, n = len(A), len(B)
    dp = [[0] * (n + 1) for i in range(m + 1)]
    max_len = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if A[i - 1] == B[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = 0
            max_len = max(max_len, dp[i][j])
    return max_len

```
